#!/bin/bash
SECONDS=0
DURATION=800
DEPTH_LIMIT[0]=13
DEPTH_LIMIT[1]=21
DEPTH_LIMIT[2]=156

export RESULT="initial"

#CURRENT_DIR="$(cd "$(dirname "$0")" && pwd)"
itr=0

# derived from the jpf-sv-comp script used by SPF in SV-COMP 2019

# create site.properties -
# when running benchexec this needs to be commented out, and site.properties file needs to be created by hand.
#SITE_PROPERTIES=site.properties
#echo "jpf-core = `pwd`/jpf-core" > $SITE_PROPERTIES
#echo "jpf-symbc = `pwd`/java-ranger" >> $SITE_PROPERTIES
#echo "extensions=\${jpf-core},\${jpf-symbc}" >> $SITE_PROPERTIES

# parse arguments
declare -a BM
BM=()
PROP_FILE=""
WITNESS_FILE=""

TOOL_BINARY=jpf-core/bin/jpf
FIND_OPTIONS="-name '*.java'"

while [ -n "$1" ] ; do
case "$1" in
  --32|--64) BIT_WIDTH="${1##--}" ; shift 1 ;;
  --propertyfile) PROP_FILE="$2" ; shift 2 ;;
  --graphml-witness) WITNESS_FILE="$2" ; shift 2 ;;
  --version) echo 2024; exit 0 ;;
  *) SRC=(`eval "find $1 $FIND_OPTIONS"`) ; BM=("${BM[@]}" "${SRC[@]}") ; shift 1 ;;
esac
done

#depth_limit=$1
#date -r java-ranger/build/jpf-symbc.jar

if [ -z "${BM[0]}" ] || [ -z "$PROP_FILE" ] ; then
echo "Missing benchmark or property file"
exit 1
fi

if [ ! -s "${BM[0]}" ] || [ ! -s "$PROP_FILE" ] ; then
echo "Empty benchmark or property file"
exit 1
fi

# we ignore the property file (there is only one property at the moment)
# we ignore the witness file (not used yet)

LOG=`mktemp -t jpf-log.XXXXXX`
DIR=`mktemp -d -t jpf-benchmark.XXXXXX`
trap "rm -rf $DIR" EXIT

# create target directory
mkdir -p $DIR/target/classes

# build src files from benchmark
/usr/lib/jvm/java-8-openjdk-amd64/bin/javac -g -cp `pwd`/java-ranger/build/classes:$DIR/target/classes:`pwd`/java-ranger/lib/JSAP-2.1.jar:`pwd`/java-ranger/lib/foundry-1.0.jar -d $DIR/target/classes "${BM[@]}"

while [ $DURATION -gt 0 ] && [ $itr -lt 3 ]
do
  #timeout $DURATION . $CURRENT_DIR/jr-sv-compStep "$@"
  rm -f $LOG
  LOG=`mktemp -t jpf-log.XXXXXX`

  ####begining of old script

  # create configuration file
  echo "target=Main" > $DIR/config.jpf
  echo "classpath=`pwd`/java-ranger/build/classes,$DIR/target/classes" >> $DIR/config.jpf
  #echo "symbolic.dp=z3bitvector" >> $DIR/config.jpf
  echo "symbolic.dp=z3bitvector" >> $DIR/config.jpf
  echo "symbolic.min_int=-2147483648" >> $DIR/config.jpf
  echo "symbolic.max_int=2147483647" >> $DIR/config.jpf
  echo "symbolic.min_double=-10000.0" >> $DIR/config.jpf
  echo "symbolic.max_double=10000.0" >> $DIR/config.jpf
  echo "symbolic.bvlength=64" >> $DIR/config.jpf
  echo "search.depth_limit=${DEPTH_LIMIT[$itr]}" >> $DIR/config.jpf
  #echo "search.depth_limit=13" >> $DIR/config.jpf
  echo "symbolic.strings=true" >> $DIR/config.jpf
  echo "symbolic.string_dp=z3str3" >> $DIR/config.jpf
  #echo "symbolic.string_range=/[A-Z]{0,4}/" >> $DIR/config.jpf
  #echo "symbolic.strings=yes" >> $DIR/config.jpf
  #echo "symbolic.string_dp=ABC" >> $DIR/config.jpf
  echo "symbolic.string_dp_timeout_ms=3000" >> $DIR/config.jpf
  echo "symbolic.lazy=on" >> $DIR/config.jpf
  #echo "symbolic.arrays=true" >> $DIR/config.jpf
  echo "symbolic.jrarrays=true" >> $DIR/config.jpf
  echo "veritestingMode = 5" >> $DIR/config.jpf
  echo "recursiveDepth= 200" >> $DIR/config.jpf
  echo "listener = .symbc.VeritestingListener" >> $DIR/config.jpf
  echo "singlePathOptimization=true" >> $DIR/config.jpf
  #echo "symbolic.optimizechoices=false" >> $DIR/config.jpf
  #echo "symbolic.fp = true" >> $DIR/config.jpf


  # run Java Ranger
  export LD_LIBRARY_PATH=`pwd`/java-ranger/lib:$LD_LIBRARY_PATH
  echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
  export TARGET_CLASSPATH_WALA=$DIR/target/classes/
  echo $TARGET_CLASSPATH_WALA
  #jpf-core/bin/jpf $DIR/config.jpf
  if test -z "$JVM_FLAGS"; then
    JVM_FLAGS="-Xmx1024m -ea"
  fi

  ulimit -t $DURATION ;  /usr/lib/jvm/java-8-openjdk-amd64/bin/java $JVM_FLAGS -Djava.library.path=/usr/local/lib -jar `pwd`/jpf-core/build/RunJPF.jar $DIR/config.jpf > $LOG

  TIMEOUT_EXIT_CODE=$?
  echo "time out code = $TIMEOUT_EXIT_CODE"
  echo "seconds  = $SECONDS"
  # check the result
  grep "no errors detected" $LOG > /dev/null
  if [ $? -eq 0 ]; then
    grep "depth limit reached" $LOG > /dev/null
    if [ $? -eq 0 ]; then
      echo " state1 = SAFE_DEPTH_REACHED"
      RESULT="SAFE_DEPTH_REACHED"
    else
      echo " state2 = SAFE"
      RESULT="SAFE"
    fi
  else
    grep "^error.*NoUncaughtExceptionsProperty.*AssertionError" $LOG > /dev/null
    if [ $? -eq 0 ]; then
      echo " state3 = UNSAFE"
      RESULT="UNSAFE"
    else
      echo " state4 = UNKNOWN"
      RESULT="UNKNOWN"
    fi
  fi

  ####end of old script

  if [ $TIMEOUT_EXIT_CODE -gt 0  ]; then #TIMEOUT happened
    #echo "inside the timeout if-stmt"
    if [ $itr -eq 0 ]; then #DEPTH_LIMIT has not changed indicating first time
      RESULT="TIMEOUT"
      break
    else
      if [ $RESULT = "UNKNOWN" ] ; then
        RESULT="SAFE" #we timed out on subsequent iterations, but you can only be here if the result was SAFE_DEPTH_REACHED
        break
      else #somehow we timed out but we got an interesting result than UNKNOWN, in which case we would want to return that
        break
      fi
    fi
  fi

  if [ $RESULT = "UNSAFE" ] || [ $RESULT = "UNKNOWN" ] || [ $RESULT = "SAFE" ]; then
    #echo "inside break if statement"
    break
  fi

  #source $CURRENT_DIR/jr-sv-compStep "$@"
  DURATION=$((DURATION-SECONDS))
  SECONDS=0
  itr=$((itr+1))
done

#parsing the output
if [ $RESULT = "SAFE_DEPTH_REACHED" ] ; then
  echo "SAFE"
else
  echo $RESULT
fi
